<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Camera Stream</title>
</head>
<body>
    <h1>Sender and Receiver</h1>
    <div class="sender">
        <h2>Sender</h2>
        <video id="video" autoplay></video>
        <canvas id="senderCanvas"></canvas>
    </div>
    <div class="receiver">
        <h2>Receiver</h2>
        <canvas id="receiverCanvas"></canvas>
    </div>
    <!-- Include the pako library for LZ77 compression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.3/pako.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();

        // Access the user's camera and start streaming
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(function (stream) {
                const videoElement = document.getElementById('video');
                videoElement.srcObject = stream;

                // Set up a Canvas element for the sender
                const senderCanvas = document.getElementById('senderCanvas');
                const senderContext = senderCanvas.getContext('2d');

                // Variables to track the previous frame and timestamp for the sender
                let prevSenderFrame = null;
                let framePart = 1; // Track the current frame part

                // Wait for the video to start playing
                videoElement.onplay = function () {
                    senderCanvas.width = videoElement.videoWidth;
                    senderCanvas.height = videoElement.videoHeight;

                    // Capture and send frames to the server
                    setInterval(function () {
                        senderContext.drawImage(videoElement, 0, 0, senderCanvas.width, senderCanvas.height);

                        // Convert the frame to a Blob with JPEG format and reduced quality
                        senderCanvas.toBlob(function (blob) {
                            if (!blob) {
                                console.error('Error converting canvas to Blob.');
                                return;
                            }

                            // Read the Blob as an ArrayBuffer
                            const reader = new FileReader();
                            reader.onload = function () {
                                const arrayBuffer = reader.result;

                                // Convert the ArrayBuffer to a Uint8Array
                                const uint8Array = new Uint8Array(arrayBuffer);

                                // Compress the frame data using LZ77
                                const compressedImageData = pako.deflate(uint8Array, { to: 'string' });

                                // Calculate the sender timestamp
                                const timestamp = Date.now();

                                // Split the compressed image into parts
                                const chunkSize = 1000; // Adjust the chunk size as needed
                                const totalParts = Math.ceil(compressedImageData.length / chunkSize);
                                const imageDataParts = [];
                                
                                console.log(compressedImageData);

                                for (let i = 0; i < totalParts; i++) {
                                    const start = i * chunkSize;
                                    const end = (i + 1) * chunkSize;
                                    const imageDataPart = compressedImageData.slice(start, end);
                                    console.log(imageDataPart);
                                    // Send the compressed frame data part and timestamp to the server
                                    if(i==totalParts-1){
                                    socket.emit('stream', { imageDataPart: imageDataPart, timestamp: timestamp, part: framePart,end: true });}

                                    else{
                                        socket.emit('stream', { imageDataPart: imageDataPart, timestamp: timestamp, part: framePart ,end:false});
                                    }

                                    
                                }

                                framePart++; // Increment the frame part

                                prevSenderFrame = compressedImageData;
                            };
                            reader.readAsArrayBuffer(blob);
                        }, 'image/jpeg', 0.04); // Adjust the image format and quality level as needed

                    }, 75); // Adjust the capture interval as needed
                };
            })
            .catch(function (error) {
                console.error('Error accessing the camera:', error);
            });

        // Set up a Canvas element for the receiver
        const receiverCanvas = document.getElementById('receiverCanvas');
        const receiverContext = receiverCanvas.getContext('2d');

        // Object to store and assemble received frame parts
        const receivedFrames = {};

        // Function to draw a frame on the receiver canvas
        function drawFrame(frameData) {
            // Decompress the received frame data using LZ77
            const decompressedUint8Array = pako.inflate(frameData, { to: 'Uint8Array' });
            const blob = new Blob([decompressedUint8Array], { type: 'image/jpeg' });

            const img = new Image();
            img.src = URL.createObjectURL(blob);

            img.onload = function () {
                receiverCanvas.width = img.width;
                receiverCanvas.height = img.height;
                receiverContext.drawImage(img, 0, 0, img.width, img.height);
            };
        }

        // Handle received frames from the server

        // Function to concatenate ArrayBuffer objects
        function concatenateArrayBuffers(arrays) {
        // Calculate the total length of all ArrayBuffers
        let totalLength = 0;
        for (const array of arrays) {
            totalLength += array.byteLength;
        }

        // Create a new ArrayBuffer with the total length
        const concatenatedArray = new ArrayBuffer(totalLength);

        // Create a view of the concatenated ArrayBuffer
        const concatenatedView = new Uint8Array(concatenatedArray);

        // Copy the data from each ArrayBuffer into the concatenated ArrayBuffer
        let offset = 0;
        for (const array of arrays) {
            const view = new Uint8Array(array);
            concatenatedView.set(view, offset);
            offset += view.length;
        }

        return concatenatedArray;
        }

        socket.on('stream', (frameData) => {
            const timestamp = frameData.timestamp;
            const imageDataPart = frameData.imageDataPart;
            const part = frameData.part;
            const end = frameData.end;

            console.log(imageDataPart);

            // Initialize the frame object if it doesn't exist
            if (!receivedFrames[part]) {
                receivedFrames[part] = { parts: [], end: false };
            }

            // Store the received frame part in the object
            receivedFrames[part].parts.push(imageDataPart);

            // Mark the end of the frame if end is true
            if (end) {
                receivedFrames[part].end = true;
                
            }

            // If all parts are received and it's marked as the end, assemble and display the frame
            if (receivedFrames[part].end) {
                const parts = receivedFrames[part].parts;
                // const partKeys = Object.keys(parts).sort((a, b) => parseInt(a) - parseInt(b));
                // const compressedImageData = partKeys.map((key) => parts[key]).join('');

                
                // Draw the assembled frame
                const uint8Array = new Uint8Array(parts);
                console.log('finished',uint8Array);
                drawFrame(concatenateArrayBuffers(parts));

                // Clear the frame object
                delete receivedFrames[part];
            }
        });

    </script>
</body>
</html>
